# -*- coding: utf-8 -*-
import cv2
import numpy as np

IMG_PATH = r"C:\Users\stefa\Documents\beeldherkenning\IMG_3734.JPG"
WINDOW   = "Afbeelding (ESC om te sluiten)"

# Max weergavegrootte (alleen verkleinen, nooit vergroten)
MAX_W, MAX_H = 1200, 800

img = cv2.imread(IMG_PATH)
if img is None:
    raise SystemExit("Kon de afbeelding niet laden.")

H, W = img.shape[:2]

# Schaalfactor om te passen binnen MAX_W x MAX_H
scale = min(MAX_W / W, MAX_H / H, 1.0)
dispW, dispH = int(W * scale), int(H * scale)

# Voorbereide display-afbeelding (geschaald als nodig)
base_disp = cv2.resize(img, (dispW, dispH), interpolation=cv2.INTER_AREA) if scale < 1.0 else img.copy()

# Huidige muispositie in display-coördinaten
mouse_xy = (0, 0)

def on_mouse(event, x, y, flags, param):
    # Alleen positie onthouden; we tekenen in de hoofdloop
    if event == cv2.EVENT_MOUSEMOVE:
        # Begrens binnen het beeld
        x_c = max(0, min(x, dispW - 1))
        y_c = max(0, min(y, dispH - 1))
        param["mouse_xy"] = (x_c, y_c)

state = {"mouse_xy": mouse_xy}

cv2.namedWindow(WINDOW, cv2.WINDOW_AUTOSIZE)
cv2.setMouseCallback(WINDOW, on_mouse, param=state)

while True:
    # Kopie om overlay op te tekenen
    disp = base_disp.copy()

    # Map display-coördinaten -> originele pixel
    x_disp, y_disp = state["mouse_xy"]
    x_src = int(round(x_disp / scale))
    y_src = int(round(y_disp / scale))
    x_src = max(0, min(x_src, W - 1))
    y_src = max(0, min(y_src, H - 1))

    b, g, r = img[y_src, x_src]
    text = f"R:{int(r)} G:{int(g)} B:{int(b)} (x:{x_src}, y:{y_src})"

    # Tekst linksonder
    cv2.putText(disp, text, (10, disp.shape[1] - 10 if False else disp.shape[0] - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2, cv2.LINE_AA)

    # Cursor markeren (optioneel)
    cv2.circle(disp, (x_disp, y_disp), 4, (255, 255, 255), -1, cv2.LINE_AA)

    cv2.imshow(WINDOW, disp)
    if (cv2.waitKey(10) & 0xFF) == 27:  # ESC om af te sluiten
        break

cv2.destroyAllWindows()

